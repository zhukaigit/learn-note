### 垃圾收集器

1. 新生代收集器类型
   都是采用复制算法
   1. **Serial**
      单线程收集器，“单线程”并不仅仅说明它只会使用一个CPU或一个线程去完成垃圾收集工作，更重要的是它在进行垃圾收集的时候，必须暂停其他所有工作线程【即 **stop the world**】。
      对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集当然可以获得更高的单线程收集效率。在用户桌面应用的场景中，分配给虚拟机管理的内存一般来说不会很大，收集几十兆到一两百兆的新生代（仅仅是新生代使用的内存，桌面应用基本上不会再大了），停顿时间基本可以控制在几十毫秒最多一百多毫秒以内，只要不是频繁发生，完全可以接受。所以Serial收集器对于运行在Client模式下的虚拟机来说是一个很好的选择。
   2. **ParNew**
      多线程收集器，相当于serial收集器的多线程版本
   3. **Parallel Scavenge**
      也是多线程收集器，CMS等收集器关注点是尽可能缩短用户线程的停顿时间，而Parallel Scavenge目的是达到一个可控的**吞吐量**（`运行用户代码时间／（运行用户代码时间 + 垃圾收集时间）`），经常被称为”吞吐量优先“收集器。并且有着自适应调节策略。
      **注意：**Parallel Scavenge收集器与G1收集器都没有使用传统的GC收集器框架，而另外独立实现，其余几种收集器则公用了部分的框架代码。
   4. G1
2. 老年代收集器类型
   1. **CMS（Concurrent Mark Sweep）**
      1. 目标：获取最短回收停顿时间。
      2. 应用：很大一部分的java应用集中在互联网或者B/S系统的服务器上，这类应用尤其看重服务器的响应速度，希望系统停顿的时间最短，以给用户带来最好的体验。CMS就十分符合这类应用需求。
      3. 收集步骤：
         - 初始标记
           仅仅只是标记一下GC Roots能**直接**关联到的对象，这一步速度很快，需要stop the world.
         - 并发标记
           这就是GC Roots trancing的过程，即标记所有间接关联到GC Roots的对象，这一步耗时相对来说比较长，但是可与用户线程并发运行
         - 重新标记
           修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记时间长一些，也需要stop the world
         - 并发清除
           这一步耗时也相对较长，但是清除垃圾对象时，可与用户线程并发运行
      4. 缺点
         - 对CPU资源非常敏感
           在并处处理过程中，虽然不会让用户线程停顿，当时会因为占用一部分线程（或者说CPU资源）而导致应用程序变慢，总吞吐量降低
         - 无法处理浮动垃圾
           由于在并发清除过程中，用户程序还在运行，会新增垃圾对象，这部分对象叫做浮动垃圾，浮动垃圾只能留在下一次才能收集掉，因此需要预留一部分内存让程序继续运行。在JDK 1.5的默认设置下，当老年代使用了68%时就会触发Full GC
         - 基于标记-清除算法，会产生内存碎片
           提供一种策略，当老年代内存顶不住时，触发内存碎片合并整理。也可设置在第几次顶不住时触发内存碎片合并整理
      5. 注意：无法与JDK 1.4.0中已经存在的新生代收集器Parallel Scavenge收集器配合工作，所以在JDK 1.5中使用CMS来收集老年代时，新生代只能选择ParNew或者Serial收集器中的一个。
   2. **Serial Old**
      采用标记-整理算法，是Serial收集器的老年代版本。
      意义：1）给Client模式下的虚拟机使用。2）配合新生代中的Parallel Scavenge，以及CMS的替代方案
   3. **Parallel Old**
      采用标记-整理算法，是Parallel Scavenge收集器的老年代版本，在JDK 1.6中才开始提供。由于Serial Old无法充分利用服务端多CPU的处理能力，因此Parallel Scavenge + Serial Old这种组合的吞吐量甚至还不如ParNew + CMS的组合给力。所以Parallel Old的出现，让Parallel Scavenge + Parallel Old这种组合成为比较名副其实的”吞吐量优先“收集器
   4. **G1**
      有两个明显的改进：一是基于标记-整理算法实现，不会产生内存碎片；二是可以非常精确的控制停顿，既能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不超过N毫秒。原因是G1将整个java堆（新生代和老年代）分成了多个大小固定的独立区域，并根据每个区域的垃圾堆积程度，在后台维护一个优先列表，每次根据收集的允许时间，优先回收垃圾最多的区域。